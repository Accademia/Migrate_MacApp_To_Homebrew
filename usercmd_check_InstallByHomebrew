#!/usr/bin/env bash

################################################################################
# 脚本：brew_check_and_repair.sh
# 说明：
#   1. 检查当前 Homebrew 安装的 Formula 和 Cask 是否正常安装；
#   2. 如果发现缺失的 Formula 或 Cask，可选择重新安装缺失项；
#   3. 检查与修复均支持并行执行（Formula 并行，Cask 顺序）；
#   4. 检查完成后输出统计信息，如 Formula 总数、Cask 总数、问题数量；
#   5. 所有输出分段打印到屏幕和日志文件，便于查看过程。
#
# 使用方法：直接运行脚本即可进行检查和修复，日志文件默认为
#   brew_installation_check.log，会自动覆盖旧日志。
################################################################################

# 禁用 -e/-u/pipefail，避免任何子命令失败或未设置变量导致脚本提前终止
set +e

# 日志文件
OUTPUT_FILE="brew_installation_check.log"
> "$OUTPUT_FILE"  # 清空旧日志

# 颜色定义（用于终端输出）。日志文件中不写入颜色控制字符。
GREEN='\033[1;32m'
RED='\033[1;31m'
CYAN='\033[1;36m'
YELLOW='\033[1;33m'
RESET='\033[0m'

# 通用打印函数：根据标签决定颜色，高亮输出到终端，同时将无颜色的信息写入日志文件。
# 用法：color_and_log "[TAG]" "message body"
color_and_log() {
    local tag="$1"
    local message="$2"
    local colored_tag
    case "$tag" in
        '[INFO]') colored_tag="${CYAN}[INFO]${RESET}" ;;
        '[ERROR]') colored_tag="${RED}[ERROR]${RESET}" ;;
        '[OK]') colored_tag="${GREEN}[OK]${RESET}" ;;
        '[REINSTALL]') colored_tag="${YELLOW}[REINSTALL]${RESET}" ;;
        '[SUMMARY]') colored_tag="${CYAN}[SUMMARY]${RESET}" ;;
        '[RESULT]') colored_tag="${CYAN}[RESULT]${RESET}" ;;
        '[FINAL RESULT]') colored_tag="${CYAN}[FINAL RESULT]${RESET}" ;;
        '[SUCCESS]') colored_tag="${GREEN}[SUCCESS]${RESET}" ;;
        '[WARN]') colored_tag="${YELLOW}[WARN]${RESET}" ;;
        *) colored_tag="$tag" ;;
    esac
    # 打印到终端
    printf "%b %s\n" "$colored_tag" "$message"
    # 写入日志文件（无颜色）
    echo "$tag $message" >> "$OUTPUT_FILE"
}

# 用于收集子进程输出的临时文件
TEMP_RESULTS=$(mktemp)

# 打印分段标题
print_section() {
    local title="$1"
    # 打印空行和分隔符
    echo "" | tee -a "$OUTPUT_FILE"
    echo "-------------------------------------------" | tee -a "$OUTPUT_FILE"
    # 标题用青色高亮输出到终端，同时写入日志
    printf "%b\n" "${CYAN}${title}${RESET}"
    echo "$title" >> "$OUTPUT_FILE"
    echo "-------------------------------------------" | tee -a "$OUTPUT_FILE"
}

# 函数：检查 Formula（与以前相同，回显结果）
check_formula() {
    local formula="$1"
    # 直接通过 brew list 检查是否有安装文件，不依赖 JSON 或 keg_only 字段
    local files
    files=$(brew list --formula "$formula" 2>/dev/null)
    if [ -z "$files" ]; then
        echo "[ERROR] Formula '$formula' => no installed files found. Possibly removed?"
        return 0
    fi
    # 查找是否存在可执行文件
    local exec_path=""
    while IFS= read -r f; do
        if [ -e "$f" ]; then
            if [[ "$f" == */bin/* ]] || [ -x "$f" ]; then
                exec_path="$f"
                break
            fi
        fi
    done <<< "$files"
    if [ -n "$exec_path" ]; then
        echo "[OK] Formula '$formula' => found executable: $exec_path"
    else
        # 没有可执行文件，但有安装文件，则认为正常安装
        echo "[OK] Formula '$formula' => installed (files found)."
    fi
    return 0
}

# 函数：检查 Cask（使用文件列表避免漏检）
check_cask() {
    local cask="$1"
    local cask_json
    cask_json=$(brew info --cask --json=v2 "$cask" 2>/dev/null)
    if [ -z "$cask_json" ]; then
        echo "[ERROR] Cask '$cask' => 'brew info --cask --json=v2' returned empty. Possibly removed or unknown?"
        return
    fi
    local app_names
    app_names=$(echo -e "$cask_json" | jq -r '
        .casks[].artifacts[] | select(has("app")) | .app[]? ' 2>/dev/null | sed 's/\.app$//')
    local cask_files
    cask_files=$(brew list --cask "$cask" 2>/dev/null)
    if [ -z "$cask_files" ]; then
        echo "[ERROR] Cask '$cask' => no files found via 'brew list --cask'. Possibly uninstalled or deleted."
    else
        local found_path=""
        local found=false
        while IFS= read -r f; do
            if [ -e "$f" ]; then
                found=true
                found_path="$f"
                break
            fi
        done <<< "$cask_files"
        if [ "$found" = true ]; then
            local status_found=false
            if [ -n "$app_names" ]; then
                while IFS= read -r app_name; do
                    local app_path="/Applications/${app_name}.app"
                    if [ -d "$app_path" ]; then
                        echo "[OK] Cask '$cask' => found .app: $app_path"
                        status_found=true
                        break
                    fi
                    local app_path_user="${HOME}/Applications/${app_name}.app"
                    if [ -d "$app_path_user" ]; then
                        echo "[OK] Cask '$cask' => found .app: $app_path_user"
                        status_found=true
                        break
                    fi
                done <<< "$app_names"
            fi
            if [ "$status_found" = false ]; then
                echo "[OK] Cask '$cask' => installed. Example file: $found_path"
            fi
        else
            echo "[ERROR] Cask '$cask' => files listed by brew but none exist. Possibly removed."
        fi
    fi
}

# 函数：执行一次检查，结果写入 TEMP_RESULTS，收集缺失项
perform_check() {
    # 清空临时结果和缺失列表，全局数组 MISSING_FORMULAE / MISSING_CASKS
    : > "$TEMP_RESULTS"
    MISSING_FORMULAE=()
    MISSING_CASKS=()

    # 获取已安装的 Formula 和 Cask
    local formulae casks
    formulae=$(brew list --formula)
    casks=$(brew list --cask)
    local formula_count cask_count total_count
    formula_count=$(echo -e "$formulae" | wc -l | tr -d ' ')
    cask_count=$(echo -e "$casks" | wc -l | tr -d ' ')
    total_count=$((formula_count + cask_count))

    color_and_log "[INFO]" "Formula count = $formula_count"
    color_and_log "[INFO]" "Cask    count = $cask_count"
    color_and_log "[INFO]" "Total   count = $total_count"

    # 使用 xargs 并行执行检查，以提升扫描速度
    export -f check_formula check_cask
    # 并行检查 Formula
    if [ -n "$formulae" ]; then
        # 尝试检测 CPU 核心数，不可用时默认为 4
        local max_jobs
        if command -v nproc >/dev/null 2>&1; then
            max_jobs=$(nproc)
        elif command -v getconf >/dev/null 2>&1; then
            max_jobs=$(getconf _NPROCESSORS_ONLN)
        else
            max_jobs=4
        fi
        if [ -z "$max_jobs" ] || [ "$max_jobs" -lt 1 ]; then
            max_jobs=4
        fi
        echo "$formulae" | xargs -n1 -P"$max_jobs" -I{} bash -c 'check_formula "$0" || true' {} >> "$TEMP_RESULTS"
    fi
    # 并行检查 Cask
    if [ -n "$casks" ]; then
        local max_jobs_cask
        if command -v nproc >/dev/null 2>&1; then
            max_jobs_cask=$(nproc)
        elif command -v getconf >/dev/null 2>&1; then
            max_jobs_cask=$(getconf _NPROCESSORS_ONLN)
        else
            max_jobs_cask=4
        fi
        if [ -z "$max_jobs_cask" ] || [ "$max_jobs_cask" -lt 1 ]; then
            max_jobs_cask=4
        fi
        echo "$casks" | xargs -n1 -P"$max_jobs_cask" -I{} bash -c 'check_cask "$0" || true' {} >> "$TEMP_RESULTS"
    fi
    # 读取结果，分类 OK 与 ERROR，并提取缺失列表
    local ok_count=0
    local error_count=0
    while IFS= read -r line; do
        [ -z "$line" ] && continue
        # 提取标记和消息
        local tag=${line%% *}
        local msg="${line#*$tag }"
        if [[ "$tag" == "[OK]" ]]; then
            # OK 行只写入日志
            echo "$line" >> "$OUTPUT_FILE"
            ((ok_count++))
        else
            # 对错误行：去掉可能嵌套的标签
            local plain_msg="$msg"
            while [[ "$plain_msg" =~ ^\[[A-Za-z\ ]+\]\  ]]; do
                plain_msg="${plain_msg#*] }"
            done
            # 高亮输出并写入日志
            color_and_log "$tag" "$plain_msg"
            ((error_count++))
            # 解析缺失的 formula 或 cask 名称，从完整的 plain_msg 中提取
            if [[ "$tag" == "[ERROR]" ]]; then
                if [[ "$plain_msg" == Formula* ]] || [[ "$plain_msg" == *"Formula '"* ]]; then
                    local tmp=${plain_msg#*\'}
                    tmp=${tmp%%\'*}
                    MISSING_FORMULAE+=("$tmp")
                elif [[ "$plain_msg" == Cask* ]] || [[ "$plain_msg" == *"Cask '"* ]]; then
                    local tmp=${plain_msg#*\'}
                    tmp=${tmp%%\'*}
                    MISSING_CASKS+=("$tmp")
                fi
            fi
        fi
    done < "$TEMP_RESULTS"
    color_and_log "[SUMMARY]" "OK: $ok_count, ERROR: $error_count"
    # 返回总数为 error_count via return value? Not needed; use arrays
}

# 函数：并行重新安装缺失的 Formula
reinstall_formulae() {
    local -a formulas=("$@");
    if [ ${#formulas[@]} -eq 0 ]; then
        color_and_log "[INFO]" "No missing formulae to reinstall."
        return
    fi
    print_section "Reinstalling missing formulae"
    # 定义单个公式的重新安装函数并导出
    reinstall_formula_one() {
        local f="$1"
        color_and_log "[REINSTALL]" "Formula $f"
        # 尝试重新安装；失败时退回到 install
        if brew reinstall "$f" &>> "$OUTPUT_FILE"; then
            color_and_log "[OK]" "Reinstalled formula $f"
        else
            # 如 reinstall 失败，尝试直接安装
            if brew install "$f" &>> "$OUTPUT_FILE"; then
                color_and_log "[OK]" "Installed formula $f"
            else
                color_and_log "[ERROR]" "Failed to reinstall or install formula $f"
            fi
        fi
    }
    export -f reinstall_formula_one color_and_log
    export GREEN RED CYAN YELLOW RESET OUTPUT_FILE
    # 批量并行安装
    printf '%s\n' "${formulas[@]}" | xargs -n1 -P4 -I{} bash -c 'reinstall_formula_one "$@"' _ {}
}

# 函数：顺序重新安装缺失的 Cask
reinstall_casks() {
    local -a casks=("$@");
    if [ ${#casks[@]} -eq 0 ]; then
        color_and_log "[INFO]" "No missing casks to reinstall."
        return
    fi
    print_section "Reinstalling missing casks"
    for cask in "${casks[@]}"; do
        color_and_log "[REINSTALL]" "Cask $cask"
        # 使用 --cask 重新安装；失败时尝试直接 install
        if brew reinstall --cask "$cask" &>> "$OUTPUT_FILE"; then
            color_and_log "[OK]" "Reinstalled cask $cask"
        else
            if brew install --cask "$cask" &>> "$OUTPUT_FILE"; then
                color_and_log "[OK]" "Installed cask $cask"
            else
                color_and_log "[ERROR]" "Failed to reinstall or install cask $cask"
            fi
        fi
    done
}

# 主流程
main() {
    print_section "HomeBrew installation check"
    perform_check
    local missing_formula_count=${#MISSING_FORMULAE[@]}
    local missing_cask_count=${#MISSING_CASKS[@]}
    color_and_log "[RESULT]" "Missing Formulae: $missing_formula_count, Missing Casks: $missing_cask_count"
    # 如果有缺失项则尝试修复
    if [ $missing_formula_count -gt 0 ] || [ $missing_cask_count -gt 0 ]; then
        print_section "Repairing missing packages"
        reinstall_formulae "${MISSING_FORMULAE[@]}"
        reinstall_casks "${MISSING_CASKS[@]}"
        # 修复后再次检查
        print_section "Re-check after repair"
        perform_check
        local final_missing_formula_count=${#MISSING_FORMULAE[@]}
        local final_missing_cask_count=${#MISSING_CASKS[@]}
        color_and_log "[FINAL RESULT]" "Missing Formulae: $final_missing_formula_count, Missing Casks: $final_missing_cask_count"
        if [ $final_missing_formula_count -eq 0 ] && [ $final_missing_cask_count -eq 0 ]; then
            color_and_log "[SUCCESS]" "All formulae and casks are OK after repair."
        else
            color_and_log "[WARN]" "Some formulae or casks are still missing after repair."
        fi
    else
        color_and_log "[SUCCESS]" "All formulae and casks are OK. No repair needed."
    fi
    # 提示日志文件位置（不使用颜色）
    echo "" | tee -a "$OUTPUT_FILE"
    printf "Results saved to %s\n" "$OUTPUT_FILE" | tee -a "$OUTPUT_FILE"
}

main "$@"
